	MagicCookieKey:   "BASIC_PLUGIN",
// GRPCServer - Required method to implement Plugin interface
func (p *Plugin) GRPCServer(broker *plugin.GRPCBroker, s *grpcx.Server) error {
	model.RegisterOverlayNetworkServer(s, &Server{Impl: p.Impl})
// Server - Here is the gRPC server that Client talks to.
type Server struct {
func (s *Server) EstimateCost(ctx context.Context, _req *model.UpdateRequest) (*model.UpdateResponse, error) {
func (s *Server) KeyExchange(ctx context.Context, _req *model.KeyExchangeRequest) (*model.KeyExchangeResponse, error) {
// Server - Required method to implement Plugin interface
func (p *Plugin) Server(*plugin.MuxBroker) (interface{}, error) {
	return &Server{Impl: p.Impl}, nil
// Server - This is the RPC server that Client talks to, conforming to the requirements of net/rpc
type Server struct {
func (s *Server) EstimateCost(_req *model.UpdateRequest, _resp *model.UpdateResponse) error {
func (s *Server) KeyExchange(_req *model.KeyExchangeRequest, _resp *model.KeyExchangeResponse) error {
// ServeConfig - This is the plugin config thet is used in main function of engine
	plugin.Serve(&plugin.ServeConfig{
		GRPCServer: plugin.DefaultGRPCServer,
	result.DestinationAutonomousSystem = new(model.AutonomousSystem)
	result.DestinationAutonomousSystem.Cost = 123
	x, _ := tcpAddressFromString(addr)
	l, err := net.Listen("tcp", x.String())
// tcpAddressFromString -
func tcpAddressFromString(addr string) (*net.TCPAddr, error) {
	h, p, err := net.SplitHostPort(addr)
	tc.SetKeepAlive(true)
	tc.SetKeepAlivePeriod(30 * time.Second)
	log.SetOutput(ioutil.Discard)
		fmt.Fprintf(os.Stderr, "Error executing CLI: %s\n", err.Error())
	gracefulTimeout = 3 * time.Second
	ShutdownCh <-chan struct{}
	defer core.Shutdown()
	err := core.Start()
		c.Ui.Error(fmt.Sprintf("[ERROR] Failed to start the overlay network daemon core: %v", err))
	return c.handleSignals(
func (c *Command) handleSignals(config *config.Config, core *Core) int {
	signalCh := make(chan os.Signal, 4)
	signal.Notify(signalCh, os.Interrupt, syscall.SIGTERM, syscall.SIGHUP)
	var sig os.Signal
	case <-c.ShutdownCh:
	case <-core.ShutdownCh():
	c.Ui.Output(fmt.Sprintf("Caught signal: %v", sig))
	if sig == syscall.SIGHUP {
	} else if sig == syscall.SIGTERM {
		if err := core.Shutdown(); err != nil {
			c.Ui.Error(fmt.Sprintf("[ERROR]: %s", err.Error()))
		c.Ui.Error(fmt.Sprintf("[ERROR] Failed to reload configs"))
		c.logFilter.SetMinLevel(minLevel)
		c.Ui.Error(fmt.Sprintf(
// Synopsis ...
func (c *Command) Synopsis() string {
  Starts our custom overlay network daemon. it is a long running process
  -config-file=foo.json         Path to a JSON file to read configuration from.
	return strings.TrimSpace(helpText)
		c.Ui.Error(fmt.Sprintf("[ERROR] Failed to create the overlay network daemon core: %v", err))
		c.Ui.Error(fmt.Sprintf(
	cmdFlags := flag.NewFlagSet(entrypoint, flag.ContinueOnError)
		c.Ui.Error(fmt.Sprintf("[ERROR] could not parse arguments : %v", err))
		c.Ui.Error(fmt.Sprintf("[ERROR]: %s", err.Error()))
	mapping, err := factory.ReadConfigPaths([]string{*configFile}, config.JSON)
		c.Ui.Error(fmt.Sprintf("[ERROR]: %s", err.Error()))
		c.Ui.Error(fmt.Sprintf("[ERROR]: %s", err.Error()))
		logOutput = os.Stderr
// Start ...
func (a *Core) Start() error {
	a.cron.Start()
// Shutdown ...
func (a *Core) Shutdown() error {
	a.cron.Stop()
// ShutdownCh ...
func (a *Core) ShutdownCh() <-chan struct{} {
			a.logger.Println(fmt.Sprintf(("error : %#v"), err.Error()))
		_, err := client.Start()
			a.logger.Printf(fmt.Sprintf(("error : %#v"), err.Error()))
			a.logger.Printf(fmt.Sprintf(("error : %#v"), err.Error()))
			a.logger.Printf(fmt.Sprintf(("error : %#v"), err.Error()))
			a.logger.Printf(fmt.Sprintf(("error : %#v"), err.Error()))
		req.SourceRouteController = &model.RouteController{
			ID:                     int32(a.conf.Self.ID),
			AutonomousSystemNumber: int32(a.conf.Self.AutonomousSystemNumber),
			IP:                     a.conf.Self.IP,
		req.DestinationAutonomousSystem = &model.AutonomousSystem{
			Number:       int32(a.conf.ConnectedAutonomousSystems[0].Number),
			LinkCapacity: int32(a.conf.ConnectedAutonomousSystems[0].LinkCapacity),
			Cost:         int32(a.conf.ConnectedAutonomousSystems[0].Cost),
			a.logger.Printf(fmt.Sprintf(("error : %#v"), err.Error()))
		a.logger.Printf(fmt.Sprintf(("state : %#v"), res))
	output := ui.OutputWriter.String()
	result, err := hex.DecodeString(output)
	cmdFlags := flag.NewFlagSet(entrypoint, flag.ContinueOnError)
	cmdFlags.Var((*flags.AppendSliceValue)(&configFiles), "config-file",
	cmdFlags.Var((*flags.AppendSliceValue)(&configFiles), "config-dir",
		c.Ui.Error(fmt.Sprintf("[ERROR] could not parse arguments : %v", err))
			c.Ui.Error(fmt.Sprintf("[ERROR]: %s", err.Error()))
			err := v.SaveAsJSON(k)
				c.Ui.Error(fmt.Sprintf("[ERROR]: %s", err.Error()))
// Synopsis ...
func (c *ParseConfigCommand) Synopsis() string {
  converts is into a normal mashalling format such as JSON.
  1 100 10.2.2.1	; RCID ASN IP Address (local rc info)
  2 200 10.1.1.2	; RCID ASN IP Address
  3 300 11.1.1.2	; RCID ASN IP Address
  4	                ; No. of ASN connected
  10 2 5 	        ; ASN Mbps(link capacity) cost
  20 5 5	        ; ASN Mbps(link capacity) cost
  200 10 5          ; ASN Mbps(link capacity) cost
  300 10 5          ; ASN Mbps(link capacity) cost
	return strings.TrimSpace(helpText)
		c.Ui.Error(fmt.Sprintf("[ERROR] could not read random data: %s", err))
		c.Ui.Error(fmt.Sprintf("[ERROR] could not read enough entropy. Generate more entropy!"))
	c.Ui.Output(hex.EncodeToString(key))
// Synopsis ...
func (c *KeygenCommand) Synopsis() string {
	return strings.TrimSpace(helpText)
	return fmt.Sprintf("Prints %s version", c.Name)
	var versionString bytes.Buffer
	fmt.Fprintf(&versionString, "%s v%s", c.Name, c.Version)
		fmt.Fprintf(&versionString, ".%s", c.VersionPrerelease)
			fmt.Fprintf(&versionString, " (%s)", c.Revision)
	c.Ui.Output(versionString.String())
// Synopsis ...
func (c *VersionCommand) Synopsis() (s string) {
	s = fmt.Sprintf("Prints %s version", c.Name)
// AppendSliceValue implements the flag.Value interface and allows multiple
type AppendSliceValue []string
var _ flag.Value = new(AppendSliceValue)
// String ...
func (s *AppendSliceValue) String() string {
// Set ...
func (s *AppendSliceValue) Set(value string) error {
func TestAppendSliceValueSet(t *testing.T) {
	sv := new(AppendSliceValue)
	err := sv.Set("foo")
	err = sv.Set("bar")
func CostEstimatorPathFlag(f *flag.FlagSet) *string {
	result := os.Getenv("OVERLAY_COST_ESTIMATOR_PLUGIN")
	return f.String("cost-estimator-path", result,
func ConfigFilePathFlag(f *flag.FlagSet) *string {
	return f.String("config-file", result,
func LogLevelFlag(f *flag.FlagSet) *string {
	return f.String("log-level", result,
func DevFlag(f *flag.FlagSet) *bool {
func RPCPortFlag(f *flag.FlagSet) *int {
func CronFlag(f *flag.FlagSet) *string {
	return f.String("cron", result,
// Commands is the mapping of all the available Serf commands.
	ui := &cli.BasicUi{Writer: os.Stdout}
				ShutdownCh: make(chan struct{}),
// makeShutdownCh returns a channel that can be used for shutdown
func makeShutdownCh() <-chan struct{} {
	signalCh := make(chan os.Signal, 4)
	return base64.StdEncoding.EncodeToString([]byte(s))
	str, err := base64.StdEncoding.DecodeString(s)
	return hex.EncodeToString([]byte(s))
	str, err := hex.DecodeString(s)
	return fmt.Sprintf("%x-%x-%x-%x-%x", uuid[0:4], uuid[4:6], uuid[6:8], uuid[8:10], uuid[10:])
		return w.md5Hash.Sum(nil)
// SHA256 ...
func (w *Writer) SHA256() []byte {
		return w.sha256Hash.Sum(nil)
// MD5HexString ...
func (w *Writer) MD5HexString() string {
	return hex.EncodeToString(res)
// MD5Base64String ...
func (w *Writer) MD5Base64String() string {
	return base64.StdEncoding.EncodeToString(res)
// SHA256HexString ...
func (w *Writer) SHA256HexString() string {
	res := w.SHA256()
	return hex.EncodeToString(res)
// SHA256Base64String ...
func (w *Writer) SHA256Base64String() string {
	res := w.SHA256()
	return base64.StdEncoding.EncodeToString(res)
		return r.md5Hash.Sum(nil)
// SHA256 ...
func (r *Reader) SHA256() []byte {
		return r.sha256Hash.Sum(nil)
// MD5HexString ...
func (r *Reader) MD5HexString() string {
	return hex.EncodeToString(res)
// MD5Base64String ...
func (r *Reader) MD5Base64String() string {
	return base64.StdEncoding.EncodeToString(res)
// SHA256HexString ...
func (r *Reader) SHA256HexString() string {
	res := r.SHA256()
	return hex.EncodeToString(res)
// SHA256Base64String ...
func (r *Reader) SHA256Base64String() string {
	res := r.SHA256()
	return base64.StdEncoding.EncodeToString(res)
		fi, err := f.Stat()
			if filepath.Ext(fi.Name()) == "."+JSON.String() {
				config, err := DecodeJSONConfig(f)
			if filepath.Ext(fi.Name()) == "."+CONF.String() {
		sort.Sort(dirEnts(contents))
			if filepath.Ext(fi.Name()) == "."+JSON.String() {
				config, err := DecodeJSONConfig(f)
			if filepath.Ext(fi.Name()) == "."+CONF.String() {
// Swap ...
func (d dirEnts) Swap(i, j int) {
// DecodeJSONConfig ...
func DecodeJSONConfig(r io.Reader) (*Config, error) {
	lines := strings.Split(string(buf), "\n")
	connectedAutonomousSystems := make([]AutonomousSystem, 0)
		parts := strings.Split(strings.TrimSpace(trimComment(lines[index])), " ")
		parts := strings.Split(strings.TrimSpace(trimComment(lines[index])), " ")
			as, err := ExtractAutonomousSystemFromLine(lines[index])
				connectedAutonomousSystems = append(connectedAutonomousSystems, *as)
	result := c.New(self, connectedRouteControllers, connectedAutonomousSystems)
	parts := SanitizeAndSplitLine(input)
		err = stacktrace.Propagate(err, "could not convert value in Autonomous System Number field '%s' to integer", parts[0])
	result.AutonomousSystemNumber = asn
// ExtractAutonomousSystemFromLine ...
func ExtractAutonomousSystemFromLine(input string) (*AutonomousSystem, error) {
	result := &AutonomousSystem{}
	parts := SanitizeAndSplitLine(input)
// SanitizeAndSplitLine ...
func SanitizeAndSplitLine(input string) []string {
	input = strings.TrimSpace(trimComment(input))
	parts := strings.Split(input, " ")
	Self                       *RouteController   `json:"self" mapstructure:"self"`
	ConnectedAutonomousSystems []AutonomousSystem `json:"connected_autonomous_systems" mapstructure:"connected_autonomous_systems"`
	AutonomousSystemNumber int    `json:"autonomous_system_number" mapstructure:"autonomous_system_number"`
// AutonomousSystem ...
type AutonomousSystem struct {
// SaveAsJSON ...
func (c *Config) SaveAsJSON(path string) error {
	path = strings.TrimSuffix(path, ext)
	enc, err := jsonutil.EncodeJSONWithIndentation(*c)
	// fmt.Println("SaveAsJSON target to stat", path)
	_, err = os.Stat(path)
	err = sink.Sync()
	// JSON ...
	JSON ConfigExtension = iota
// String ...
func (e ConfigExtension) String() string {
	case JSON:
	connectedAutonomousSystems []AutonomousSystem,
		Self:                       self,
		ConnectedAutonomousSystems: connectedAutonomousSystems,
// EncodeJSONWithoutErr ...
func EncodeJSONWithoutErr(in interface{}) []byte {
	res, _ := EncodeJSON(in)
// EncodeJSON - Encodes/Marshals the given object into JSON
func EncodeJSON(in interface{}) ([]byte, error) {
	stream := jsoniter.ConfigFastest.BorrowStream(nil)
	defer jsoniter.ConfigFastest.ReturnStream(stream)
		return nil, stacktrace.Propagate(stream.Error, "Failed to encode JSON")
// DecodeJSON ...
func DecodeJSON(data []byte, out interface{}) error {
		return stacktrace.Propagate(iter.Error, "Failed to decode JSON Blob")
func EncodeJSONWithIndentation(in interface{}) ([]byte, error) {
	EncodeJSONToWriter(buf, in, "", "    ")
// EncodeJSONToWriter - encodes/marshals a given interface
func EncodeJSONToWriter(w io.Writer, in interface{}, prefix, indent string) error {
	enc.SetEscapeHTML(true)
		enc.SetIndent(prefix, indent)
// DecodeJSONFromReader - Decodes/Unmarshals the given
// io.Reader pointing to a JSON, into a desired object
func DecodeJSONFromReader(r io.Reader, out interface{}) error {
func TestJSONUtil_EncodeJSON(t *testing.T) {
	actualBytes, err := jsonutil.EncodeJSON(input)
		t.Fatalf("failed to encode JSON: %v", err)
	actual := strings.TrimSpace(string(actualBytes))
		t.Fatalf("bad: encoded JSON: expected:%s\nactual:%s\n", expected, string(actualBytes))
func TestJSONUtil_DecodeJSON(t *testing.T) {
	err := jsonutil.DecodeJSON([]byte(input), &actual)
func TestJSONUtil_DecodeJSONFromReader(t *testing.T) {
	err := jsonutil.DecodeJSONFromReader(bytes.NewReader([]byte(input)), &actual)
func BenchmarkJSONUtil_EncodeJSON(b *testing.B) {
		_, err := jsonutil.EncodeJSON(input)
			b.Fatalf("failed to encode JSON: %v", err)
func BenchmarkStdLib_EncodeJSON(b *testing.B) {
func BenchmarkJSONUtil_DecodeJSON(b *testing.B) {
		err := jsonutil.DecodeJSON([]byte(input), &actual)
func BenchmarkStdLib_DecodeJSON(b *testing.B) {
func BenchmarkJSONUtil_DecodeJSONFromReader(b *testing.B) {
		err := jsonutil.DecodeJSONFromReader(bytes.NewReader([]byte(input)), &actual)
func BenchmarkStdlib_DecodeJSONFromReader(b *testing.B) {
	if buf.String() != "" {
		t.Fatalf("bad: %s", buf.String())
	if buf.String() != "foo\nbar\n" {
		t.Fatalf("bad: %s", buf.String())
	if buf.String() != "foo\nbar\nbaz\n" {
		t.Fatalf("bad: %s", buf.String())
// JSON2 -
type JSON2 struct {
func GenerateRPC2Routes(routes []JSON2) *mux.Router {
	router := mux.NewRouter().PathPrefix("/").Subrouter()
	s := rpc.NewServer()
		s.RegisterService(route.Handler, route.Namespace)
	router := mux.NewRouter().PathPrefix("/").Subrouter()
	// router := mux.NewRouter().StrictSlash(true)
// WriteErrorJSON ...
func WriteErrorJSON(w *http.ResponseWriter, r *http.Request, code int, message string) {
	response, err := jsonutil.EncodeJSON(Error{
	(*w).Header().Set("Content-Type", "application/json; charset=UTF-8")
	(*w).Header().Set("Content-Length", strconv.Itoa(len(response)))
// WriteSuccessfulJSON - logs and sends a new json response to the client
func WriteSuccessfulJSON(w *http.ResponseWriter, r *http.Request, data interface{}) {
	LogSuccessfulResponse(r, data)
	(*w).Header().Set("Content-Type", "application/json; charset=UTF-8")
	(*w).WriteHeader(http.StatusOK)
	response, err := jsonutil.EncodeJSON(data)
	(*w).Header().Set("Content-Length", strconv.Itoa(len(response)))
// LogSuccessfulResponse ...
func LogSuccessfulResponse(r *http.Request, data interface{}) {
	response.WriteSuccessfulJSON(&w, r, map[string]interface{}{
	w.WriteHeader(http.StatusOK)
		w.Header().Set("Access-Control-Allow-Headers", "Accept, Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization")
		w.Header().Set("Content-Type", "application/json; charset=UTF-8")
		w.Header().Set("Access-Control-Allow-Origin", "*")
		w.Header().Set("Access-Control-Allow-Methods", "POST, GET, OPTIONS, PUT, DELETE")
		next.ServeHTTP(w, r)
		next.ServeHTTP(w, r)
				w.Header().Set("Content-Type", "application/json; charset=UTF-8")
				w.WriteHeader(http.StatusUnauthorized)
			authHeaderParts := strings.Split(authHeader, " ")
				w.Header().Set("Content-Type", "application/json; charset=UTF-8")
				w.WriteHeader(http.StatusUnauthorized)
				w.Header().Set("Content-Type", "application/json; charset=UTF-8")
				w.WriteHeader(http.StatusUnauthorized)
			next.ServeHTTP(w, r.WithContext(ctx))
func parse(secret, tokenString string) (jwt.MapClaims, error) {
	token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
// SetTestLogger ...
func SetTestLogger(t *testing.T) {
// SetDefaultLogger ...
func SetDefaultLogger() {
		Log: log.New(os.Stderr, "", log.LstdFlags),
	return fmt.Sprintf("[%s] %s", level, msg)
	extraString := ""
		extraString = fmt.Sprintf("%s%s=%v ", extraString, k, v)
	if extraString != "" {
		msg = extraString + msg
	Sha256               string   `protobuf:"bytes,2,opt,name=sha256,proto3" json:"sha256,omitempty"`
// String ...
func (m *Hash) String() string { return proto.CompactTextString(m) }
// XXX_Size ...
func (m *Hash) XXX_Size() int {
	return xxx_messageInfo_Hash.Size(m)
// GetSha256 ...
func (m *Hash) GetSha256() string {
		return m.Sha256
	AutonomousSystemNumber int32    `protobuf:"varint,2,opt,name=autonomous_system_number,json=autonomousSystemNumber,proto3" json:"autonomous_system_number,omitempty"`
// String ...
func (m *RouteController) String() string { return proto.CompactTextString(m) }
// XXX_Size ...
func (m *RouteController) XXX_Size() int {
	return xxx_messageInfo_RouteController.Size(m)
// GetAutonomousSystemNumber ...
func (m *RouteController) GetAutonomousSystemNumber() int32 {
		return m.AutonomousSystemNumber
// AutonomousSystem ...
type AutonomousSystem struct {
func (m *AutonomousSystem) Reset() { *m = AutonomousSystem{} }
// String ...
func (m *AutonomousSystem) String() string { return proto.CompactTextString(m) }
func (*AutonomousSystem) ProtoMessage() {}
func (*AutonomousSystem) Descriptor() ([]byte, []int) {
func (m *AutonomousSystem) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AutonomousSystem.Unmarshal(m, b)
func (m *AutonomousSystem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AutonomousSystem.Marshal(b, m, deterministic)
func (m *AutonomousSystem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AutonomousSystem.Merge(m, src)
// XXX_Size ...
func (m *AutonomousSystem) XXX_Size() int {
	return xxx_messageInfo_AutonomousSystem.Size(m)
func (m *AutonomousSystem) XXX_DiscardUnknown() {
	xxx_messageInfo_AutonomousSystem.DiscardUnknown(m)
var xxx_messageInfo_AutonomousSystem proto.InternalMessageInfo
func (m *AutonomousSystem) GetNumber() int32 {
func (m *AutonomousSystem) GetLinkCapacity() int32 {
func (m *AutonomousSystem) GetCost() int32 {
	SourceRouteController       *RouteController  `protobuf:"bytes,2,opt,name=source_route_controller,json=sourceRouteController,proto3" json:"source_route_controller,omitempty"`
	DestinationAutonomousSystem *AutonomousSystem `protobuf:"bytes,3,opt,name=destination_autonomous_system,json=destinationAutonomousSystem,proto3" json:"destination_autonomous_system,omitempty"`
// String ...
func (m *UpdateRequest) String() string { return proto.CompactTextString(m) }
// XXX_Size ...
func (m *UpdateRequest) XXX_Size() int {
	return xxx_messageInfo_UpdateRequest.Size(m)
// GetSourceRouteController ...
func (m *UpdateRequest) GetSourceRouteController() *RouteController {
		return m.SourceRouteController
// GetDestinationAutonomousSystem ...
func (m *UpdateRequest) GetDestinationAutonomousSystem() *AutonomousSystem {
		return m.DestinationAutonomousSystem
	DestinationAutonomousSystem *AutonomousSystem `protobuf:"bytes,2,opt,name=destination_autonomous_system,json=destinationAutonomousSystem,proto3" json:"destination_autonomous_system,omitempty"`
// String ...
func (m *UpdateResponse) String() string { return proto.CompactTextString(m) }
// XXX_Size ...
func (m *UpdateResponse) XXX_Size() int {
	return xxx_messageInfo_UpdateResponse.Size(m)
// GetDestinationAutonomousSystem ...
func (m *UpdateResponse) GetDestinationAutonomousSystem() *AutonomousSystem {
		return m.DestinationAutonomousSystem
// String ...
func (m *KeyExchangeRequest) String() string { return proto.CompactTextString(m) }
// XXX_Size ...
func (m *KeyExchangeRequest) XXX_Size() int {
	return xxx_messageInfo_KeyExchangeRequest.Size(m)
// String ...
func (m *KeyExchangeResponse) String() string { return proto.CompactTextString(m) }
// XXX_Size ...
func (m *KeyExchangeResponse) XXX_Size() int {
	return xxx_messageInfo_KeyExchangeResponse.Size(m)
	proto.RegisterType((*AutonomousSystem)(nil), "model.AutonomousSystem")
const _ = grpc.SupportPackageIsVersion4
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
// OverlayNetworkServer is the server API for OverlayNetwork service.
type OverlayNetworkServer interface {
// UnimplementedOverlayNetworkServer can be embedded to have forward compatible implementations.
type UnimplementedOverlayNetworkServer struct {
func (*UnimplementedOverlayNetworkServer) EstimateCost(ctx context.Context, req *UpdateRequest) (*UpdateResponse, error) {
func (*UnimplementedOverlayNetworkServer) KeyExchange(ctx context.Context, req *KeyExchangeRequest) (*KeyExchangeResponse, error) {
// RegisterOverlayNetworkServer ...
func RegisterOverlayNetworkServer(s *grpc.Server, srv OverlayNetworkServer) {
	s.RegisterService(&_OverlayNetwork_serviceDesc, srv)
func _OverlayNetwork_EstimateCost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
		return srv.(OverlayNetworkServer).EstimateCost(ctx, in)
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		return srv.(OverlayNetworkServer).EstimateCost(ctx, req.(*UpdateRequest))
func _OverlayNetwork_KeyExchange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
		return srv.(OverlayNetworkServer).KeyExchange(ctx, in)
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		return srv.(OverlayNetworkServer).KeyExchange(ctx, req.(*KeyExchangeRequest))
var _OverlayNetwork_serviceDesc = grpc.ServiceDesc{
	ServiceName: "model.OverlayNetwork",
	HandlerType: (*OverlayNetworkServer)(nil),
	Streams:  []grpc.StreamDesc{},
	return strings.TrimSpace(buf.String())
	return fmt.Sprintf("(version=%s, branch=%s, revision=%s)", Version, Branch, Revision)
	return fmt.Sprintf("(go=%s, user=%s, date=%s)", GoVersion, BuildUser, BuildDate)
